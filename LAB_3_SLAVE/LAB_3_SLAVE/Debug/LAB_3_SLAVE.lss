
LAB_3_SLAVE.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  000002d6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000262  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000001  00800100  00800100  000002d6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000002d6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000308  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000068  00000000  00000000  00000348  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000a1e  00000000  00000000  000003b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000007de  00000000  00000000  00000dce  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000004c5  00000000  00000000  000015ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000fc  00000000  00000000  00001a74  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000005b1  00000000  00000000  00001b70  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000296  00000000  00000000  00002121  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000048  00000000  00000000  000023b7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 3b 00 	jmp	0x76	; 0x76 <__ctors_end>
   4:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
   8:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
   c:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  10:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  14:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  18:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  1c:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  20:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  24:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  28:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  2c:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  30:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  34:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  38:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  3c:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  40:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  44:	0c 94 00 01 	jmp	0x200	; 0x200 <__vector_17>
  48:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  4c:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  50:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  54:	0c 94 e7 00 	jmp	0x1ce	; 0x1ce <__vector_21>
  58:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  5c:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  60:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  64:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  68:	67 00       	.word	0x0067	; ????
  6a:	6e 00       	.word	0x006e	; ????
  6c:	75 00       	.word	0x0075	; ????
  6e:	7f 00       	.word	0x007f	; ????
  70:	89 00       	.word	0x0089	; ????
  72:	93 00       	.word	0x0093	; ????
  74:	9d 00       	.word	0x009d	; ????

00000076 <__ctors_end>:
  76:	11 24       	eor	r1, r1
  78:	1f be       	out	0x3f, r1	; 63
  7a:	cf ef       	ldi	r28, 0xFF	; 255
  7c:	d8 e0       	ldi	r29, 0x08	; 8
  7e:	de bf       	out	0x3e, r29	; 62
  80:	cd bf       	out	0x3d, r28	; 61

00000082 <__do_clear_bss>:
  82:	21 e0       	ldi	r18, 0x01	; 1
  84:	a0 e0       	ldi	r26, 0x00	; 0
  86:	b1 e0       	ldi	r27, 0x01	; 1
  88:	01 c0       	rjmp	.+2      	; 0x8c <.do_clear_bss_start>

0000008a <.do_clear_bss_loop>:
  8a:	1d 92       	st	X+, r1

0000008c <.do_clear_bss_start>:
  8c:	a1 30       	cpi	r26, 0x01	; 1
  8e:	b2 07       	cpc	r27, r18
  90:	e1 f7       	brne	.-8      	; 0x8a <.do_clear_bss_loop>
  92:	0e 94 c0 00 	call	0x180	; 0x180 <main>
  96:	0c 94 2f 01 	jmp	0x25e	; 0x25e <_exit>

0000009a <__bad_interrupt>:
  9a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000009e <SPI_init>:
#define F_CPU 16000000UL
#include "SPI.h"

void SPI_init(SPI_TYPE sType, SPI_Data_Order sDataOrder, SPI_Clock_Polarity sClockPolarity, SPI_Clock_Phase sClockPhase) {
  9e:	e8 2f       	mov	r30, r24
	//PB2 -> SS
	//PB3 -> SS
	//PB4 -> SS
	//PB5 -> SS
	
	if (sType & 0x10) { //Verificar si se configura como maestro..
  a0:	84 ff       	sbrs	r24, 4
  a2:	52 c0       	rjmp	.+164    	; 0x148 <SPI_init+0xaa>
		// Configurar como maestro
		DDRB |= (1 << DDB3) | (1 << DDB5) | (1 << DDB2); // MOSI, SCK, SS como salidas
  a4:	84 b1       	in	r24, 0x04	; 4
  a6:	8c 62       	ori	r24, 0x2C	; 44
  a8:	84 b9       	out	0x04, r24	; 4
		DDRB &= ~(1 << DDB4); // MISO como entrada
  aa:	84 b1       	in	r24, 0x04	; 4
  ac:	8f 7e       	andi	r24, 0xEF	; 239
  ae:	84 b9       	out	0x04, r24	; 4
		SPCR |= (1 << MSTR); // Habilitar modo maestro
  b0:	8c b5       	in	r24, 0x2c	; 44
  b2:	80 61       	ori	r24, 0x10	; 16
  b4:	8c bd       	out	0x2c, r24	; 44
		
		uint8_t temp = sType & 0b00000111;
  b6:	e7 70       	andi	r30, 0x07	; 7
		switch(temp){
  b8:	8e 2f       	mov	r24, r30
  ba:	90 e0       	ldi	r25, 0x00	; 0
  bc:	87 30       	cpi	r24, 0x07	; 7
  be:	91 05       	cpc	r25, r1
  c0:	08 f0       	brcs	.+2      	; 0xc4 <SPI_init+0x26>
  c2:	4b c0       	rjmp	.+150    	; 0x15a <SPI_init+0xbc>
  c4:	fc 01       	movw	r30, r24
  c6:	ec 5c       	subi	r30, 0xCC	; 204
  c8:	ff 4f       	sbci	r31, 0xFF	; 255
  ca:	0c 94 29 01 	jmp	0x252	; 0x252 <__tablejump2__>
			case 0: //DIV2
				SPCR &= ~((1<<SPR1)|(1<<SPR0));
  ce:	8c b5       	in	r24, 0x2c	; 44
  d0:	8c 7f       	andi	r24, 0xFC	; 252
  d2:	8c bd       	out	0x2c, r24	; 44
				SPSR |= (1<<SPI2X);
  d4:	8d b5       	in	r24, 0x2d	; 45
  d6:	81 60       	ori	r24, 0x01	; 1
  d8:	8d bd       	out	0x2d, r24	; 45
			break;
  da:	3f c0       	rjmp	.+126    	; 0x15a <SPI_init+0xbc>
			case 1: //DIV4
				SPCR &= ~((1<<SPR1)|(1<<SPR0));
  dc:	8c b5       	in	r24, 0x2c	; 44
  de:	8c 7f       	andi	r24, 0xFC	; 252
  e0:	8c bd       	out	0x2c, r24	; 44
				SPSR &= ~(1<<SPI2X);
  e2:	8d b5       	in	r24, 0x2d	; 45
  e4:	8e 7f       	andi	r24, 0xFE	; 254
  e6:	8d bd       	out	0x2d, r24	; 45
			break;
  e8:	38 c0       	rjmp	.+112    	; 0x15a <SPI_init+0xbc>
			case 2: //DIV8
				SPCR |= (1<<SPR0);
  ea:	8c b5       	in	r24, 0x2c	; 44
  ec:	81 60       	ori	r24, 0x01	; 1
  ee:	8c bd       	out	0x2c, r24	; 44
				SPCR &= ~(1<<SPR1);
  f0:	8c b5       	in	r24, 0x2c	; 44
  f2:	8d 7f       	andi	r24, 0xFD	; 253
  f4:	8c bd       	out	0x2c, r24	; 44
				SPSR |= (1<<SPI2X);
  f6:	8d b5       	in	r24, 0x2d	; 45
  f8:	81 60       	ori	r24, 0x01	; 1
  fa:	8d bd       	out	0x2d, r24	; 45
			break;
  fc:	2e c0       	rjmp	.+92     	; 0x15a <SPI_init+0xbc>
			case 3: //DIV16
				SPCR |= (1<<SPR0);
  fe:	8c b5       	in	r24, 0x2c	; 44
 100:	81 60       	ori	r24, 0x01	; 1
 102:	8c bd       	out	0x2c, r24	; 44
				SPCR &= ~(1<<SPR1);
 104:	8c b5       	in	r24, 0x2c	; 44
 106:	8d 7f       	andi	r24, 0xFD	; 253
 108:	8c bd       	out	0x2c, r24	; 44
				SPSR &= ~(1<<SPI2X);
 10a:	8d b5       	in	r24, 0x2d	; 45
 10c:	8e 7f       	andi	r24, 0xFE	; 254
 10e:	8d bd       	out	0x2d, r24	; 45
			break;
 110:	24 c0       	rjmp	.+72     	; 0x15a <SPI_init+0xbc>
			case 4: //DIV32
				SPCR &= ~(1<<SPR0);
 112:	8c b5       	in	r24, 0x2c	; 44
 114:	8e 7f       	andi	r24, 0xFE	; 254
 116:	8c bd       	out	0x2c, r24	; 44
				SPCR |= (1<<SPR1);
 118:	8c b5       	in	r24, 0x2c	; 44
 11a:	82 60       	ori	r24, 0x02	; 2
 11c:	8c bd       	out	0x2c, r24	; 44
				SPSR |= (1<<SPI2X);
 11e:	8d b5       	in	r24, 0x2d	; 45
 120:	81 60       	ori	r24, 0x01	; 1
 122:	8d bd       	out	0x2d, r24	; 45
			break;
 124:	1a c0       	rjmp	.+52     	; 0x15a <SPI_init+0xbc>
			case 5: //DIV64
				SPCR &= ~(1<<SPR0);
 126:	8c b5       	in	r24, 0x2c	; 44
 128:	8e 7f       	andi	r24, 0xFE	; 254
 12a:	8c bd       	out	0x2c, r24	; 44
				SPCR |= (1<<SPR1);
 12c:	8c b5       	in	r24, 0x2c	; 44
 12e:	82 60       	ori	r24, 0x02	; 2
 130:	8c bd       	out	0x2c, r24	; 44
				SPSR &= ~(1<<SPI2X);
 132:	8d b5       	in	r24, 0x2d	; 45
 134:	8e 7f       	andi	r24, 0xFE	; 254
 136:	8d bd       	out	0x2d, r24	; 45
			break;
 138:	10 c0       	rjmp	.+32     	; 0x15a <SPI_init+0xbc>
			case 6: //DIV128
				SPCR |= (1<<SPR0)|(1<<SPR1);
 13a:	8c b5       	in	r24, 0x2c	; 44
 13c:	83 60       	ori	r24, 0x03	; 3
 13e:	8c bd       	out	0x2c, r24	; 44
				SPSR &= ~(1<<SPI2X);
 140:	8d b5       	in	r24, 0x2d	; 45
 142:	8e 7f       	andi	r24, 0xFE	; 254
 144:	8d bd       	out	0x2d, r24	; 45
			break;
 146:	09 c0       	rjmp	.+18     	; 0x15a <SPI_init+0xbc>
		}
		
		} else {
		// Configurar como esclavo
		DDRB |= (1 << DDB4); // MISO como salida
 148:	84 b1       	in	r24, 0x04	; 4
 14a:	80 61       	ori	r24, 0x10	; 16
 14c:	84 b9       	out	0x04, r24	; 4
		DDRB &= ~((1 << DDB3) | (1 << DDB5) | (1 << DDB2)); // MOSI, SCK, SS como entradas
 14e:	84 b1       	in	r24, 0x04	; 4
 150:	83 7d       	andi	r24, 0xD3	; 211
 152:	84 b9       	out	0x04, r24	; 4
		
		SPCR &= ~(1 << MSTR); // Habilitar SPI, modo esclavo
 154:	8c b5       	in	r24, 0x2c	; 44
 156:	8f 7e       	andi	r24, 0xEF	; 239
 158:	8c bd       	out	0x2c, r24	; 44
	}
	// Habilitar Data Order, Clock Polarity, Clock Phase
	SPCR |= (1<<SPE)|sDataOrder|sClockPolarity|sClockPhase;
 15a:	8c b5       	in	r24, 0x2c	; 44
 15c:	46 2b       	or	r20, r22
 15e:	24 2b       	or	r18, r20
 160:	28 2b       	or	r18, r24
 162:	20 64       	ori	r18, 0x40	; 64
 164:	2c bd       	out	0x2c, r18	; 44
 166:	08 95       	ret

00000168 <SPI_send>:
}

void SPI_send(uint8_t data) {
	SPDR = data;
 168:	8e bd       	out	0x2e, r24	; 46
	while (!(SPSR & (1 << SPIF))); // Esperar a que la transmisión termine
 16a:	0d b4       	in	r0, 0x2d	; 45
 16c:	07 fe       	sbrs	r0, 7
 16e:	fd cf       	rjmp	.-6      	; 0x16a <SPI_send+0x2>
}
 170:	08 95       	ret

00000172 <initADC>:
}

void initADC(void)
{
	// Seleccionar ADC7
	ADMUX = (1<<REFS0) | (1<<ADLAR) | 7;  // Vref = AVCC, Justificación a la izquierda, Seleccionar ADC7
 172:	87 e6       	ldi	r24, 0x67	; 103
 174:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7f807c>

	// Encender ADC
	ADCSRA = (1<<ADEN) | (1<<ADIE) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);  // Habilitar ADC, habilitar interrupción, preescalar de 128
 178:	8f e8       	ldi	r24, 0x8F	; 143
 17a:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7f807a>
 17e:	08 95       	ret

00000180 <main>:
void initADC(void);

int main(void)
{
	// Configurar Pines como salida
	DDRD |= (1<<DDD2)|(1<<DDD3)|(1<<DDD4)|(1<<DDD5)|(1<<DDD6)|(1<<DDD7);
 180:	8a b1       	in	r24, 0x0a	; 10
 182:	8c 6f       	ori	r24, 0xFC	; 252
 184:	8a b9       	out	0x0a, r24	; 10
	DDRB |= (1<<DDB0)|(1<<DDB1);
 186:	84 b1       	in	r24, 0x04	; 4
 188:	83 60       	ori	r24, 0x03	; 3
 18a:	84 b9       	out	0x04, r24	; 4
	
	PORTD &= ~((1<<DDD2)|(1<<DDD3)|(1<<DDD4)|(1<<DDD5)|(1<<DDD6)|(1<<DDD7));
 18c:	8b b1       	in	r24, 0x0b	; 11
 18e:	83 70       	andi	r24, 0x03	; 3
 190:	8b b9       	out	0x0b, r24	; 11
	PORTB &= ~((1<<DDB0)|(1<<DDB1));
 192:	85 b1       	in	r24, 0x05	; 5
 194:	8c 7f       	andi	r24, 0xFC	; 252
 196:	85 b9       	out	0x05, r24	; 5
	
	SPI_init(SPI_SLAVE_SS, SPI_Data_Order_MSB, SPI_Clock_IDLE_LOW, SPI_clock_First_EDGE);
 198:	20 e0       	ldi	r18, 0x00	; 0
 19a:	40 e0       	ldi	r20, 0x00	; 0
 19c:	60 e0       	ldi	r22, 0x00	; 0
 19e:	80 e4       	ldi	r24, 0x40	; 64
 1a0:	0e 94 4f 00 	call	0x9e	; 0x9e <SPI_init>
	initADC();
 1a4:	0e 94 b9 00 	call	0x172	; 0x172 <initADC>
	SPCR |= (1<<SPIE); // Activar ISR SPI
 1a8:	8c b5       	in	r24, 0x2c	; 44
 1aa:	80 68       	ori	r24, 0x80	; 128
 1ac:	8c bd       	out	0x2c, r24	; 44
	sei();
 1ae:	78 94       	sei
	
	while (1)
	{
		ADCSRA |= (1<<ADSC);
 1b0:	ea e7       	ldi	r30, 0x7A	; 122
 1b2:	f0 e0       	ldi	r31, 0x00	; 0
 1b4:	80 81       	ld	r24, Z
 1b6:	80 64       	ori	r24, 0x40	; 64
 1b8:	80 83       	st	Z, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 1ba:	2f ef       	ldi	r18, 0xFF	; 255
 1bc:	81 ee       	ldi	r24, 0xE1	; 225
 1be:	94 e0       	ldi	r25, 0x04	; 4
 1c0:	21 50       	subi	r18, 0x01	; 1
 1c2:	80 40       	sbci	r24, 0x00	; 0
 1c4:	90 40       	sbci	r25, 0x00	; 0
 1c6:	e1 f7       	brne	.-8      	; 0x1c0 <main+0x40>
 1c8:	00 c0       	rjmp	.+0      	; 0x1ca <main+0x4a>
 1ca:	00 00       	nop
 1cc:	f1 cf       	rjmp	.-30     	; 0x1b0 <main+0x30>

000001ce <__vector_21>:

	
}

ISR(ADC_vect)
{
 1ce:	1f 92       	push	r1
 1d0:	0f 92       	push	r0
 1d2:	0f b6       	in	r0, 0x3f	; 63
 1d4:	0f 92       	push	r0
 1d6:	11 24       	eor	r1, r1
 1d8:	8f 93       	push	r24
 1da:	ef 93       	push	r30
 1dc:	ff 93       	push	r31
	valorADC = ADCH;
 1de:	80 91 79 00 	lds	r24, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7f8079>
 1e2:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
	ADCSRA |= (1<<ADIF);
 1e6:	ea e7       	ldi	r30, 0x7A	; 122
 1e8:	f0 e0       	ldi	r31, 0x00	; 0
 1ea:	80 81       	ld	r24, Z
 1ec:	80 61       	ori	r24, 0x10	; 16
 1ee:	80 83       	st	Z, r24
}
 1f0:	ff 91       	pop	r31
 1f2:	ef 91       	pop	r30
 1f4:	8f 91       	pop	r24
 1f6:	0f 90       	pop	r0
 1f8:	0f be       	out	0x3f, r0	; 63
 1fa:	0f 90       	pop	r0
 1fc:	1f 90       	pop	r1
 1fe:	18 95       	reti

00000200 <__vector_17>:

ISR(SPI_STC_vect)
{
 200:	1f 92       	push	r1
 202:	0f 92       	push	r0
 204:	0f b6       	in	r0, 0x3f	; 63
 206:	0f 92       	push	r0
 208:	11 24       	eor	r1, r1
 20a:	2f 93       	push	r18
 20c:	3f 93       	push	r19
 20e:	4f 93       	push	r20
 210:	5f 93       	push	r21
 212:	6f 93       	push	r22
 214:	7f 93       	push	r23
 216:	8f 93       	push	r24
 218:	9f 93       	push	r25
 21a:	af 93       	push	r26
 21c:	bf 93       	push	r27
 21e:	ef 93       	push	r30
 220:	ff 93       	push	r31
	uint8_t valorSPI = SPDR;
 222:	8e b5       	in	r24, 0x2e	; 46
	if (valorSPI == 'c') {
 224:	83 36       	cpi	r24, 0x63	; 99
 226:	21 f4       	brne	.+8      	; 0x230 <__vector_17+0x30>
		SPI_send(valorADC);
 228:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 22c:	0e 94 b4 00 	call	0x168	; 0x168 <SPI_send>
	}
}
 230:	ff 91       	pop	r31
 232:	ef 91       	pop	r30
 234:	bf 91       	pop	r27
 236:	af 91       	pop	r26
 238:	9f 91       	pop	r25
 23a:	8f 91       	pop	r24
 23c:	7f 91       	pop	r23
 23e:	6f 91       	pop	r22
 240:	5f 91       	pop	r21
 242:	4f 91       	pop	r20
 244:	3f 91       	pop	r19
 246:	2f 91       	pop	r18
 248:	0f 90       	pop	r0
 24a:	0f be       	out	0x3f, r0	; 63
 24c:	0f 90       	pop	r0
 24e:	1f 90       	pop	r1
 250:	18 95       	reti

00000252 <__tablejump2__>:
 252:	ee 0f       	add	r30, r30
 254:	ff 1f       	adc	r31, r31
 256:	05 90       	lpm	r0, Z+
 258:	f4 91       	lpm	r31, Z
 25a:	e0 2d       	mov	r30, r0
 25c:	09 94       	ijmp

0000025e <_exit>:
 25e:	f8 94       	cli

00000260 <__stop_program>:
 260:	ff cf       	rjmp	.-2      	; 0x260 <__stop_program>
